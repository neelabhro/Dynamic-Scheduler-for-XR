/*
 * System.cpp
 *
 *  Created on: Jan 17, 2017
 *      Author: Sladjana
 */

#include "System.h"

LoggerPtr System::logger(Logger::getLogger("System"));

System::System(){
	initialized_from = -1;
}

System::System(int init_how, YAML::Node config) {
	logger->setLevel(log4cxx::Level::getDebug());
	initialized_from = init_how;
	if( init_how == INIT_FROM_DESCRIPTION){
	
		N=config["N"].as<float>();	
		slot_length=config["slot_length"].as<float>();		

		init_lambdas(config);

		
	}	
	else{

		//TODO update if the parameters are not set from description

	}
}

System::~System() {
	// TODO Auto-generated destructor stub
}


void System::init_lambdas(YAML::Node config) {
	if (config["lambda_i"]["type"]){
		string demands_type=config["lambda_i"]["type"].as<string>();
		if (demands_type.compare("uniform")==0){
			float a,b;
			a = config["lambda_i"]["a"].as<float>();
			b = config["lambda_i"]["b"].as<float>();

			lambda_i = Tools::generate_uniform_vector(a,b,N);
		}
		else if (demands_type.compare("scalar") == 0){
			LOG4CXX_DEBUG(logger,"Demands set to the constant for all MUs");
			for (int i = 0; i < N; i++){
				lambda_i.push_back(config["lambda_i"]["value"].as<double>());
			}
		}
	}
	else{
		LOG4CXX_DEBUG(logger,"Demands generated by uniformly from 0 and 1");
		lambda_i = Tools::generate_uniform_vector(0.0,1.0,N);
	}

	//call compute_aggr_demands on the root node
	//compute_aggr_demands(root);
}




map<double, vector<vector<double> > > Stats_on_arrivals::compute_statistics_on_arrival(map<double, Task> g_arrival_events, int n_Mus, double time_interval) {
	map <double, vector< vector <double> > > statistics;

	/*
	 * Deciding positioning of estimates in vector
	 */
	const int ARRIVALS = 0;
	//TODO add other statistics, e.g., average size of the frames
	const int N_FIELDS = 1;

	//Initialize new vector
	vector<vector <double> > current_stats (n_Mus,vector <double> (N_FIELDS,0.0));

	//set estimation expiration
	double est_expiration = time_interval;

	for(auto event : g_arrival_events){



		//If time of event after expiration, save stats and restart counting
		if (event.first > est_expiration){

			//Computing ALL averages

			for (int mu = 0; mu < n_Mus; mu ++){
				current_stats[mu][ARRIVALS]/=time_interval;
			}


			//saving vector
			statistics.insert(pair<double, vector<vector <double> >>(est_expiration,current_stats));


			//reset current statistics
			current_stats = vector<vector <double> > (n_Mus,vector <double> (N_FIELDS,0.0));

			//reset timer
			est_expiration+=time_interval;

		}

		int mu = event.second.origin_id;
		//Here update stats		
		current_stats[mu][ARRIVALS]+=1.0;


	}

	return statistics;

}




std::ostream& operator<<(std::ostream &strm, const System &a) {
	strm << "Instance of simulation:"<<endl;
	strm << "\tN= "<<a.N<<";"<<endl;
	return  strm;
}

YAML::Emitter& operator << (YAML::Emitter& out, const System& a) {
	out << YAML::BeginMap;
	out << YAML::Key <<"N" << YAML::Value << a.N;
	//TODO implement for the rest of the relevant parameters, e.g., frame size...
	out << YAML::EndMap;
	return out;
}
